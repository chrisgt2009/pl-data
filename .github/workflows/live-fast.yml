name: Live PL (fast)

# Serialize any writer to main (must match refresh-data.yml)
concurrency:
  group: pl-data-commit
  cancel-in-progress: false

on:
  schedule:
    # Weekends: every 5 min 11:00–21:59 UTC
    - cron: "*/5 11-21 * * 6,0"
    # Weekday evenings: every 10 min 18:00–22:59 UTC
    - cron: "*/10 18-22 * * 1-5"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  live:
    runs-on: ubuntu-latest
    env:
      FD_TOKEN: ${{ secrets.FD_API_TOKEN }}
      UA: live-bot/1.0 (+github.com/${{ github.repository }})

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # so we can pull --rebase before pushing

      - name: Ensure data dir
        run: mkdir -p data

      - name: Today (UTC)
        id: d
        shell: bash
        run: |
          echo "TODAY=$(date -u +%Y-%m-%d)" >> "$GITHUB_OUTPUT"

      - name: Fetch today with ETag
        id: fetch
        shell: bash
        run: |
          set -e

          # read existing ETag (if any) via python -c (no heredoc here -> no YAML issues)
          old_etag=""
          if [ -f data/etags.json ]; then
            old_etag="$(python -c 'import json,os; p="data/etags.json"; print(json.load(open(p)).get("today","") if os.path.exists(p) else "")' 2>/dev/null || true)"
          fi

          URL="https://api.football-data.org/v4/competitions/PL/matches?dateFrom=${{ steps.d.outputs.TODAY }}&dateTo=${{ steps.d.outputs.TODAY }}"

          if [ -n "$old_etag" ]; then
            code=$(curl -sS --fail --retry 3 --retry-delay 2 --connect-timeout 15 \
                    -H "User-Agent: $UA" \
                    -H "X-Auth-Token: $FD_TOKEN" \
                    -H "If-None-Match: $old_etag" \
                    -D headers.txt -o today.raw.json --write-out "%{http_code}" "$URL" || true)
          else
            code=$(curl -sS --fail --retry 3 --retry-delay 2 --connect-timeout 15 \
                    -H "User-Agent: $UA" \
                    -H "X-Auth-Token: $FD_TOKEN" \
                    -D headers.txt -o today.raw.json --write-out "%{http_code}" "$URL" || true)
          fi

          echo "code=$code" >> "$GITHUB_OUTPUT"

          # extract new ETag if 200
          if [ "$code" = "200" ]; then
            new_etag=$(awk 'BEGIN{IGNORECASE=1} /^etag:/{print $2; exit}' headers.txt 2>/dev/null | tr -d '\r' || true)
            echo "any_changed=true" >> "$GITHUB_OUTPUT"
            echo "new_t=$new_etag"  >> "$GITHUB_OUTPUT"
          else
            echo "any_changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build live_today.json
        if: steps.fetch.outputs.any_changed == 'true'
        shell: bash
        run: |
          python - <<'PY'
          import json, datetime
          from datetime import timezone

          now = datetime.datetime.now(timezone.utc)

          with open("today.raw.json") as f:
              today = json.load(f)

          def phase(status, utc_iso, now_utc):
              try:
                  kick = datetime.datetime.fromisoformat((utc_iso or "").replace("Z","+00:00"))
              except Exception:
                  return None, ""
              mins = int(max(0, (now_utc - kick).total_seconds() // 60))
              if status == "SCHEDULED": return mins, "Today"
              if status == "IN_PLAY":
                  return (mins, f"{mins}’") if mins < 90 else (mins, f"90+{mins-90}’")
              if status == "PAUSED": return 45, "Half-Time"
              if status == "FINISHED": return 90, "FT"
              return mins, status or ""

          live=[]
          for m in (today.get("matches") or []):
              st=m.get("status"); utc=m.get("utcDate")
              mins,label=phase(st,utc,now)
              ft=(m.get("score") or {}).get("fullTime") or {}
              h=(m.get("homeTeam") or {}); a=(m.get("awayTeam") or {})
              live.append({
                  "id": m.get("id"),
                  "utcDate": utc,
                  "status": st,
                  "approxMinute": mins,
                  "phase": label,
                  "home": {"id": h.get("id"), "tla": h.get("tla"), "name": h.get("name"),
                           "score": ft.get("home")},
                  "away": {"id": a.get("id"), "tla": a.get("tla"), "name": a.get("name"),
                           "score": ft.get("away")}
              })

          out = {"serverNowUTC": now.isoformat(), "lastUpdatedUTC": now.isoformat(), "matches": live}
          with open("data/live_today.new.json","w") as f:
              json.dump(out, f, separators=(",",":"), sort_keys=True)
          PY

      - name: Update ETag store
        if: steps.fetch.outputs.any_changed == 'true'
        shell: bash
        run: |
          python - <<'PY'
          import json, os
          p='data/etags.json'
          et={}
          if os.path.exists(p):
            try: et=json.load(open(p))
            except: et={}
          new_t=os.environ.get('NEW_T')
          if new_t: et['today']=new_t
          json.dump(et, open('data/etags.new.json','w'), separators=(',',':'), sort_keys=True)
          PY
        env:
          NEW_T: ${{ steps.fetch.outputs.new_t }}

      - name: Commit only if changed
        if: steps.fetch.outputs.any_changed == 'true'
        shell: bash
        run: |
          set -e

          CHANGED=0
          for f in live_today etags; do
            if [ -f "data/$f.json" ] && [ -f "data/$f.new.json" ]; then
              if cmp -s "data/$f.new.json" "data/$f.json"; then
                rm -f "data/$f.new.json"
              else
                mv "data/$f.new.json" "data/$f.json"
                CHANGED=1
              fi
            elif [ -f "data/$f.new.json" ]; then
              mv "data/$f.new.json" "data/$f.json"
              CHANGED=1
            fi
          done

          if [ $CHANGED -eq 1 ]; then
            git config user.name "pl-bot"
            git config user.email "pl-bot@users.noreply.github.com"

            git add data/*.json
            git commit -m "Update live_today $(date -u +%Y-%m-%dT%H:%M:%SZ)"

            # make sure we're up to date, then push; retry once on conflict
            git fetch origin main
            git pull --rebase origin main || true

            if ! git push origin HEAD:main; then
              echo "Push failed; retrying after rebase..."
              git pull --rebase origin main || true
              git push origin HEAD:main
            fi
          else
            echo "No JSON changes to commit."
          fi
