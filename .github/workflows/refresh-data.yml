name: refresh-data

on:
  workflow_dispatch:
    inputs:
      force:
        description: "Force refresh (ignore ETags and re-write if body differs)"
        required: false
        default: "false"
  schedule:
    # --- Live windows (UTC): every 10 minutes ---
    - cron: "*/10 18-22 * * 1-5"  # Weekdays (Mon–Fri): 18:00–22:59
    - cron: "*/10 11-22 * * 6,0"  # Weekends (Sat–Sun): 11:00–22:59
    # --- Outside live windows (lighter to save free minutes) ---
    - cron: "0 8,12,16,23 * * 1-5"        # Weekdays: 4x/day
    - cron: "0 9,12,15,18,21 * * 6,0"     # Weekends: 5x/day

permissions:
  contents: write
  actions: read

# Do NOT cancel in-progress runs
concurrency:
  group: refresh-data-${{ github.ref }}
  cancel-in-progress: false

env:
  DAILY_LIMIT: "300"                         # refresh-data + fast-live/live-fast
  FORCE_REFRESH: ${{ github.event.inputs.force || 'false' }}

jobs:
  refresh:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---------- Daily budget gate (robust) ----------
      - id: quota
        name: Daily budget gate
        shell: bash
        env:
          DAILY_LIMIT: ${{ env.DAILY_LIMIT }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          TODAY="$(date -u +%Y-%m-%d)"
          jq_today='[ .[] | select(((.createdAt // "") | tostring) | startswith($TODAY)) ] | length'

          used_refresh=$({ gh run list --workflow "refresh-data" --json createdAt,status --limit 200 || echo '[]'; } \
                         | jq -r --arg TODAY "$TODAY" "$jq_today")
          used_fast_a=$({ gh run list --workflow "fast-live"  --json createdAt,status --limit 200 || echo '[]'; } \
                         | jq -r --arg TODAY "$TODAY" "$jq_today")
          used_fast_b=$({ gh run list --workflow "live-fast"  --json createdAt,status --limit 200 || echo '[]'; } \
                         | jq -r --arg TODAY "$TODAY" "$jq_today")

          total=$(( used_refresh + used_fast_a + used_fast_b ))
          remaining=$(( DAILY_LIMIT - total ))
          (( remaining < 0 )) && remaining=0

          echo "used=$total" >> "$GITHUB_OUTPUT"
          echo "remaining=$remaining" >> "$GITHUB_OUTPUT"
          echo "allow=$([ "$remaining" -gt 0 ] && echo true || echo false)" >> "$GITHUB_OUTPUT"

      - name: Budget exhausted — skip run
        if: steps.quota.outputs.allow == 'false'
        run: echo "Daily limit reached (used=${{ steps.quota.outputs.used }}). Skipping refresh."

      # ---------- Ensure repo paths ----------
      - name: Prepare data directory
        if: steps.quota.outputs.allow == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p data
          [[ -f data/etags.json ]] || echo '{}' > data/etags.json

      # ---------- Initialize summary ----------
      - name: Init job summary
        if: steps.quota.outputs.allow == 'true'
        shell: bash
        run: |
          {
            echo "## Refresh summary"
            echo ""
            echo "- Force refresh: **${FORCE_REFRESH}**"
            echo "- Daily used: **${{ steps.quota.outputs.used }}** / $DAILY_LIMIT"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      # ==================== FETCHERS ====================

      # ---- STANDINGS ----
      - id: standings
        if: steps.quota.outputs.allow == 'true'
        name: Refresh standings (ETag-aware)
        shell: bash
        env:
          URL: ${{ vars.URL_STANDINGS }}        # e.g. https://api.football-data.org/v4/competitions/PL/standings
          AUTH_HEADER: ${{ secrets.API_AUTH_HEADER }}
          EXTRA_HEADER: ${{ secrets.API_EXTRA_HEADER }}
          FORCE_REFRESH: ${{ env.FORCE_REFRESH }}
        run: |
          set -euo pipefail
          KEY="standings"
          TMPHDR="$(mktemp)"; TMPBODY="$(mktemp)"
          [[ -z "${URL:-}" ]] && { echo "URL_STANDINGS not set; skipping."; echo "changed=false" >> "$GITHUB_OUTPUT"; exit 0; }

          IN_ETAG=""; [[ "$FORCE_REFRESH" != "true" ]] && IN_ETAG=$(jq -r --arg k "$KEY" '.[$k] // empty' data/etags.json)
          HDRS=()
          [[ -n "${AUTH_HEADER:-}" ]]  && HDRS+=(-H "$AUTH_HEADER")
          [[ -n "${EXTRA_HEADER:-}" ]] && HDRS+=(-H "$EXTRA_HEADER")
          if [[ "$FORCE_REFRESH" != "true" && -n "$IN_ETAG" ]]; then
            HDRS+=(-H "If-None-Match: $IN_ETAG")
          fi

          CODE=$(curl -sS -w "%{http_code}" -D "$TMPHDR" -o "$TMPBODY" "${HDRS[@]}" "$URL")
          echo "code=$CODE" >> "$GITHUB_OUTPUT"

          if [[ "$CODE" == "304" && "$FORCE_REFRESH" != "true" ]]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          elif [[ "$CODE" != "200" ]]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            NORM="$(mktemp)"; jq -S -c '.' "$TMPBODY" > "$NORM" || { echo "changed=false" >> "$GITHUB_OUTPUT"; exit 0; }
            if [[ "$FORCE_REFRESH" == "true" ]] || ! cmp -s "$NORM" "data/standings.json"; then
              mv "$NORM" "data/standings.json"
              echo "changed=true" >> "$GITHUB_OUTPUT"
            else
              rm -f "$NORM"; echo "changed=false" >> "$GITHUB_OUTPUT"
            fi
            NEW_ETAG=$(sed -n 's/^etag:[[:space:]]*//Ip' "$TMPHDR" | tr -d '\r' | tail -n1)
            [[ -n "$NEW_ETAG" ]] && tmp="$(mktemp)"; jq --arg k "$KEY" --arg v "$NEW_ETAG" '.[$k]=$v' data/etags.json > "$tmp" && mv "$tmp" data/etags.json || true
            echo "inEtag=${IN_ETAG:-}"  >> "$GITHUB_OUTPUT"
            echo "outEtag=${NEW_ETAG:-}" >> "$GITHUB_OUTPUT"
          fi

          {
            echo "### Standings"
            echo "- URL: \`$URL\`"
            echo "- HTTP: **$CODE**"
            echo "- If-None-Match sent: \`${IN_ETAG:-none}\` (force=${FORCE_REFRESH})"
            echo "- Changed: **${{ steps.standings.outputs.changed || 'false' }}**"
          } >> "$GITHUB_STEP_SUMMARY"

      # ---- FIXTURES (30 days; multi-endpoint fallback; safe write; rich diagnostics) ----
      - id: fixtures_week
        if: steps.quota.outputs.allow == 'true'
        name: Refresh fixtures (30 days, with fallbacks)
        shell: bash
        env:
          BASE: ${{ vars.URL_FIXTURES }}    # e.g. https://api.football-data.org/v4/matches?competitions=PL
          AUTH_HEADER: ${{ secrets.API_AUTH_HEADER }}    # e.g. X-Auth-Token: <token>
          EXTRA_HEADER: ${{ secrets.API_EXTRA_HEADER }}  # optional
          FORCE_REFRESH: ${{ env.FORCE_REFRESH }}
        run: |
          set -euo pipefail
          
          # CRITICAL FIXES: Initialize ALL flow variables at the start.
          changed="false" 
          total=0
          summary=""
          
          : "${BASE:=https://api.football-data.org/v4/matches?competitions=PL}"
          ALT_BASE="https://api.football-data.org/v4/competitions/PL/matches"

          START_FROM="$(date -u +%Y-%m-%d)"
          END_TO="$(date -u -d '+30 days' +%Y-%m-%d)"
          OUT="data/fixtures_week.json"

          COMBINED="$(mktemp)"
          echo '{"matches":[]}' > "$COMBINED"
          

          # ---------- helpers ----------
          hdrs() {
            local a=()
            [[ -n "${AUTH_HEADER:-}"  ]] && a+=(-H "$AUTH_HEADER")
            [[ -n "${EXTRA_HEADER:-}" ]] && a+=(-H "$EXTRA_HEADER")
            printf '%s\n' "${a[@]}"
          }

          fetch_slice() {
            # $1 = base, $2 = from, $3 = to, $4 = tmp_hdr, $5 = tmp_body
            local base="$1" from="$2" to="$3" tmp_hdr="$4" tmp_body="$5"
            local sep url code
            sep='&'; [[ "$base" == *\?* ]] || sep='?'
            url="${base}${sep}dateFrom=${from}&dateTo=${to}&status=SCHEDULED,TIMED"
            # Use '|| true' to ensure the command substitution doesn't fail on connection error
            code=$(curl -sS -w "%{http_code}" -D "$tmp_hdr" -o "$tmp_body" $(hdrs) "$url" || true) 
            printf '%s\n' "$code|$url"
          }

          count_matches() {
            # $1 = json file
            jq -r '(.matches // []) | length' "$1" 2>/dev/null || echo 0
          }

          merge_into() {
            # $1 = combined.json, $2 = slice.json
            jq -s '{matches: (.[0].matches + (try .[1].matches // []) | unique_by(.id) | sort_by(.utcDate))}' \
              "$1" "$2"
          }

          snippet() {
            # $1 = file
            head -c 220 "$1" | tr -d '\000'
          }

          attempt() {
            # $1 = base url
            local base="$1" slice_total=0
            for off in 0 10 20; do
              local from to tmp_hdr tmp_body
              from="$(date -u -d "+${off} days" +%Y-%m-%d)"
              to="$(date -u -d "+$((off+10)) days" +%Y-%m-%d)"
              tmp_hdr="$(mktemp)"; tmp_body="$(mktemp)"

              IFS='|' read -r code url <<<"$(fetch_slice "$base" "$from" "$to" "$tmp_hdr" "$tmp_body")"
              cnt="$(count_matches "$tmp_body")"
              slice_total=$((slice_total + cnt))

              # Add diagnostics; if 200 but empty, show snippet (often an error payload)
              if [[ "$code" == "200" && "$cnt" -gt 0 ]]; then
                merge_into "$COMBINED" "$tmp_body" > "${COMBINED}.new" && mv "${COMBINED}.new" "$COMBINED"
                summary+="- ${from} → ${to}: **${code}**, matches: **${cnt}** \n"
              else
                short="$(snippet "$tmp_body" || true)"
                summary+="- ${from} → ${to}: **${code}**, matches: **${cnt}**${short:+ — _${short}_}  \n"
              fi
            done
            echo "$slice_total"
          }

          # Attempt 1: global endpoint with competitions filter (best on free)
          a1=$(attempt "$BASE")
          total=$((total + a1))

          # Attempt 2: competition endpoint if still empty
          if [[ "$total" -eq 0 ]]; then
            summary+="\n_Fallback to competition endpoint_\n"
            a2=$(attempt "$ALT_BASE")
            total=$((total + a2))
          fi

          # Attempt 3: final fallback (no dates) to at least get "next" scheduled
          if [[ "$total" -eq 0 ]]; then
            summary+="\n_Final fallback (no dates, scheduled/timed only)_\n"
            tmp_hdr="$(mktemp)"; tmp_body="$(mktemp)"
            url="${ALT_BASE}?status=SCHEDULED,TIMED"
            code=$(curl -sS -w "%{http_code}" -D "$tmp_hdr" -o "$tmp_body" $(hdrs) "$url" || true)
            cnt="$(count_matches "$tmp_body")"
            if [[ "$code" == "200" && "$cnt" -gt 0 ]]; then
              jq -S '{matches:.matches}' "$tmp_body" > "${COMBINED}.new" && mv "${COMBINED}.new" "$COMBINED"
              total=$((total + cnt))
            fi
            short="$(snippet "$tmp_body" || true)"
            summary+="- no-date call: **${code}**, matches: **${cnt}**${short:+ — _${short}_}  \n"
          fi

          # Build envelope
          NORM="$(mktemp)"
          # CRITICAL FIX: Ensure safe expansion of START_FROM and END_TO for jq
          jq -S --arg df "${START_FROM}" --arg dt "${END_TO}" \
              '{filters:{dateFrom:$df,dateTo:$dt},matches:.matches}' \
              "$COMBINED" > "$NORM"

          # 'changed' is already initialized to "false"
          if [[ "$total" -gt 0 ]]; then
            if [[ "${FORCE_REFRESH:-false}" == "true" ]] || [[ ! -f "$OUT" ]] || ! cmp -s "$NORM" "$OUT"; then
              mv "$NORM" "$OUT"
              changed="true"
            else
              rm -f "$NORM"
            fi
          else
            rm -f "$NORM"
            echo "All attempts returned 0 matches; ${OUT} left unchanged."
            # 'changed' remains "false" here, preventing the set -u crash on the next line
          fi

          echo "changed=$changed" >> "$GITHUB_OUTPUT"

          {
            echo "### Fixtures (30 days)"
            echo "- Force refresh: ${FORCE_REFRESH:-false}"
            echo "- Window: \`${START_FROM}\` → \`${END_TO}\`"
            echo ""
            echo -e "${summary}"
            echo "- Merged total: **${total}**"
            echo "- Changed: **${changed}**"
            [[ -f "$OUT" ]] && echo "- File: \`${OUT}\`"
          } >> "$GITHUB_STEP_SUMMARY"

      # ---- SCORERS ----
      - id: scorers
        if: steps.quota.outputs.allow == 'true'
        name: Refresh scorers (ETag-aware)
        shell: bash
        env:
          URL: ${{ vars.URL_SCORERS }}        # e.g. https://api.football-data.org/v4/competitions/PL/scorers
          AUTH_HEADER: ${{ secrets.API_AUTH_HEADER }}
          EXTRA_HEADER: ${{ secrets.API_EXTRA_HEADER }}
          FORCE_REFRESH: ${{ env.FORCE_REFRESH }}
        run: |
          set -euo pipefail
          KEY="scorers"
          TMPHDR="$(mktemp)"; TMPBODY="$(mktemp)"
          [[ -z "${URL:-}" ]] && { echo "URL_SCORERS not set; skipping."; echo "changed=false" >> "$GITHUB_OUTPUT"; exit 0; }

          IN_ETAG=""; [[ "$FORCE_REFRESH" != "true" ]] && IN_ETAG=$(jq -r --arg k "$KEY" '.[$k] // empty' data/etags.json)
          HDRS=()
          [[ -n "${AUTH_HEADER:-}" ]]  && HDRS+=(-H "$AUTH_HEADER")
          [[ -n "${EXTRA_HEADER:-}" ]] && HDRS+=(-H "$EXTRA_HEADER")
          if [[ "$FORCE_REFRESH" != "true" && -n "$IN_ETAG" ]]; then
            HDRS+=(-H "If-None-Match: $IN_ETAG")
          fi

          CODE=$(curl -sS -w "%{http_code}" -D "$TMPHDR" -o "$TMPBODY" "${HDRS[@]}" "$URL")
          echo "code=$CODE" >> "$GITHUB_OUTPUT"

          if [[ "$CODE" == "304" && "$FORCE_REFRESH" != "true" ]]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          elif [[ "$CODE" != "200" ]]; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            NORM="$(mktemp)"; jq -S -c '.' "$TMPBODY" > "$NORM" || { echo "changed=false" >> "$GITHUB_OUTPUT"; exit 0; }
            if [[ "$FORCE_REFRESH" == "true" ]] || ! cmp -s "$NORM" "data/scorers.json"; then
              mv "$NORM" "data/scorers.json"
              echo "changed=true" >> "$GITHUB_OUTPUT"
            else
              rm -f "$NORM"; echo "changed=false" >> "$GITHUB_OUTPUT"
            fi
            NEW_ETAG=$(sed -n 's/^etag:[[:space:]]*//Ip' "$TMPHDR" | tr -d '\r' | tail -n1)
            [[ -n "$NEW_ETAG" ]] && tmp="$(mktemp)"; jq --arg k "$KEY" --arg v "$NEW_ETAG" '.[$k]=$v' data/etags.json > "$tmp" && mv "$tmp" data/etags.json || true
            echo "inEtag=${IN_ETAG:-}"  >> "$GITHUB_OUTPUT"
            echo "outEtag=${NEW_ETAG:-}" >> "$GITHUB_OUTPUT"
          fi

          {
            echo "### Scorers"
            echo "- URL: \`$URL\`"
            echo "- HTTP: **$CODE**"
            echo "- If-None-Match sent: \`${IN_ETAG:-none}\` (force=${FORCE_REFRESH})"
            echo "- Changed: **${{ steps.scorers.outputs.changed || 'false' }}**"
          } >> "$GITHUB_STEP_SUMMARY"

      # ---------- meta.json (always emit when any changed) ----------
      - id: meta
        if: steps.quota.outputs.allow == 'true' && (steps.standings.outputs.changed == 'true' || steps.fixtures_week.outputs.changed == 'true' || steps.scorers.outputs.changed == 'true')
        name: Update meta.json
        shell: bash
        run: |
          set -euo pipefail
          LAST="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          jq -S -c --arg t "$LAST" '
            .lastUpdatedUTC = $t
            | .artifacts = {
                standings:      {file:"data/standings.json",      etag:(.standings      // "")},
                fixtures_week: {file:"data/fixtures_week.json", etag:(."fixtures_week" // "")},
                scorers:        {file:"data/scorers.json",        etag:(.scorers        // "")}
              }
          ' data/etags.json \
          | jq -S -c '{lastUpdatedUTC, artifacts}' \
          > meta.new.json

          if ! cmp -s meta.new.json data/meta.json; then
            mv meta.new.json data/meta.json
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            rm -f meta.new.json
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

          {
            echo "### Meta"
            echo "- Updated: **${{ steps.meta.outputs.changed || 'false' }}**"
          } >> "$GITHUB_STEP_SUMMARY"

      # ---------- Commit only when something changed ----------
      - name: Commit & push
        if: steps.quota.outputs.allow == 'true'
        shell: bash
        run: |
          set -euo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/standings.json data/fixtures_week.json data/scorers.json data/meta.json data/etags.json 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No changes to commit."
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "> No file diffs detected, nothing to commit." >> "$GITHUB_STEP_SUMMARY"
          else
            git commit -m "Update PL data $(date -u +%FT%TZ)"
            git push
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "> ✅ Changes committed." >> "$GITHUB_STEP_SUMMARY"
          fi
