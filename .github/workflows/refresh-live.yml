name: Refresh Live (Premier League)

on:
  schedule:
    # GitHub minimum granularity is 5 minutes; cron is UTC
    - cron: "*/5 * * * *"
  workflow_dispatch:
    inputs:
      force_fetch:
        description: "Force run even if preflight would skip (manual only)"
        type: boolean
        default: false
        required: false

permissions:
  contents: write

concurrency:
  group: pl-live-refresh
  cancel-in-progress: true

jobs:
  live:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    env:
      URL_LIVE: ${{ vars.URL_LIVE }} # https://v3.football.api-sports.io/fixtures?live=all

      RAPIDAPI_KEY: ${{ secrets.RAPIDAPI_KEY }}
      RAPIDAPI_HOST: ${{ secrets.RAPIDAPI_HOST }}

      LEAGUE_ID: ${{ vars.LEAGUE_ID_PL }}  # 39
      SEASON: ${{ vars.SEASON_PL }}        # 2025

      EVENTS_URL: "https://v3.football.api-sports.io/fixtures/events?fixture="
      LINEUPS_URL: "https://v3.football.api-sports.io/fixtures/lineups?fixture="
      STATS_URL: "https://v3.football.api-sports.io/fixtures/statistics?fixture="

      # Your quota
      DAILY_CAP: "7500"
      SOFT_CAP: "7200"

      # Keep updating after FT
      POST_WINDOW_SECONDS: "5400" # 90m

      # Pull data if kickoff is near (helps lineups show up pre-match)
      NEAR_KICKOFF_SECONDS: "5400" # 90m

      # Pacing
      PER_REQUEST_SLEEP_MS: "200"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install jq and perl
        run: |
          sudo apt-get update
          sudo apt-get install -y jq perl

      - name: Ensure folders
        run: |
          mkdir -p data/football/premier-league/live
          mkdir -p data/football/premier-league/fixtures
          mkdir -p data/football/premier-league/matches
          mkdir -p data/ops

      # -----------------------------
      # Quota state (reset per day)
      # -----------------------------
      - id: quota
        name: Quota state (load/reset per day)
        shell: bash
        run: |
          set -euo pipefail
          STATE="data/ops/live_usage.json"
          LONDON_DATE=$(TZ=Europe/London date +%F)

          CURR_DATE=""
          COUNT=0
          if [[ -f "$STATE" ]]; then
            CURR_DATE=$(jq -r '.date // ""' "$STATE")
            COUNT=$(jq -r '.count // 0' "$STATE")
          fi

          if [[ "$CURR_DATE" != "$LONDON_DATE" ]]; then
            COUNT=0
          fi

          jq -n --arg date "$LONDON_DATE" --argjson count "$COUNT" '{date:$date, count:$count}' > "$STATE"

          echo "count=$COUNT" >> "$GITHUB_OUTPUT"

      - id: cap
        name: Quota guard (soft cap)
        shell: bash
        run: |
          set -euo pipefail
          COUNT=${{ steps.quota.outputs.count }}
          if (( COUNT >= SOFT_CAP )); then
            echo "over=true" >> "$GITHUB_OUTPUT"
          else
            echo "over=false" >> "$GITHUB_OUTPUT"
          fi

      # ---------------------------------------------------------
      # Preflight: decide whether to fetch at all
      # ---------------------------------------------------------
      - id: preflight
        name: Preflight (should we fetch?)
        shell: bash
        run: |
          set -euo pipefail

          LIVE_OUT="data/football/premier-league/live/live_today.json"
          FIX="data/football/premier-league/fixtures/fixtures_week.json"
          POST="data/ops/post_window.json"

          SHOULD="no"

          # 1) If post-window flag is fresh -> yes
          if [[ -f "$POST" ]]; then
            NOW=$(date -u +%s)
            TS=$(jq -r '.ts // 0' "$POST")
            AGE=$((NOW - TS))
            if (( AGE >= 0 && AGE <= ${POST_WINDOW_SECONDS} )); then
              SHOULD="yes"
            fi
          fi

          # 2) If fixtures_week exists and a kickoff is within NEAR window -> yes
          if [[ "$SHOULD" == "no" && -f "$FIX" ]]; then
            NOW=$(date -u +%s)
            NEAR=$(jq --argjson now "$NOW" --argjson win "${NEAR_KICKOFF_SECONDS}" '
              def to_ts($s):
                (try ($s
                  | sub("\\.[0-9]{3}Z$"; "Z")
                  | strptime("%Y-%m-%dT%H:%M:%S%z")
                  | mktime) catch null);

              [.matches[]? | .fixture.date as $d | to_ts($d)]
              | map(select(. != null and (. - $now) >= 0 and (. - $now) <= $win))
              | length > 0
            ' "$FIX")
            if [[ "$NEAR" == "true" ]]; then
              SHOULD="yes"
            fi
          fi

          # 3) If we already have live_today.json and it showed live last time -> yes
          if [[ "$SHOULD" == "no" && -f "$LIVE_OUT" ]]; then
            LIVE=$(jq -r '
              [.matches[]? | .fixture.status.short // "" | ascii_upcase]
              | any(.=="1H" or .=="HT" or .=="2H" or .=="ET" or .=="P" or .=="LIVE")
            ' "$LIVE_OUT" || echo "false")
            if [[ "$LIVE" == "true" ]]; then
              SHOULD="yes"
            fi
          fi

          echo "should_fetch=$SHOULD" >> "$GITHUB_OUTPUT"

      # ---------------------------------------------------------
      # Fetch live list + per-fixture details (events/lineups/stats)
      # Writes into matches/<fixtureId>/...
      # ---------------------------------------------------------
      - id: fetch
        name: Fetch live list + match detail refresh (events/lineups/stats)
        if: (steps.preflight.outputs.should_fetch == 'yes' || inputs.force_fetch == true) && steps.cap.outputs.over != 'true'
        shell: bash
        run: |
          set -euo pipefail

          LIVE_OUT="data/football/premier-league/live/live_today.json"
          FIX="data/football/premier-league/fixtures/fixtures_week.json"
          POST="data/ops/post_window.json"
          STATE="data/ops/live_usage.json"

          COUNT=$(jq -r '.count // 0' "$STATE")
          CALLS_USED=0
          ANY_CHANGED="false"

          ms_sleep() {
            local ms="$1"
            if command -v perl >/dev/null 2>&1; then
              perl -e "select(undef, undef, undef, ${ms}/1000.0);"
            else
              sleep 1
            fi
          }

          # Generic API GET with 429 backoff; wraps output with meta; writes only if changed
          api_get_wrap() {
            local url="$1"
            local out_file="$2"
            local wrap_key="$3" # matches|events|lineups|stats

            # Hard cap check
            if (( COUNT + CALLS_USED >= DAILY_CAP )); then
              return 99
            fi

            local tmpbody; tmpbody="$(mktemp)"
            local code=""
            local attempt=1

            while (( attempt <= 3 )); do
              code=$(curl -sS --connect-timeout 5 --max-time 25 -w "%{http_code}" -o "$tmpbody" \
                -H "x-rapidapi-key: ${RAPIDAPI_KEY}" \
                -H "x-rapidapi-host: ${RAPIDAPI_HOST}" \
                "$url" || true)

              CALLS_USED=$((CALLS_USED + 1))

              if [[ "$code" == "429" && "$attempt" -lt 3 ]]; then
                backoff=$((2**attempt))
                sleep "$backoff"
                attempt=$((attempt + 1))
                continue
              fi
              break
            done

            if [[ "$code" != "200" ]]; then
              rm -f "$tmpbody"
              return 2
            fi

            local ok
            ok=$(jq -r '(.response | type) == "array"' "$tmpbody" 2>/dev/null || echo "false")
            if [[ "$ok" != "true" ]]; then
              rm -f "$tmpbody"
              return 3
            fi

            local ts norm
            ts=$(date -u +%FT%TZ)
            norm="$(mktemp)"

            jq --arg ts "$ts" --arg key "$wrap_key" '
              { ($key): .response, meta: { lastUpdatedUTC: $ts } }
            ' "$tmpbody" > "$norm"

            mkdir -p "$(dirname "$out_file")"
            if [[ ! -f "$out_file" ]] || ! cmp -s "$norm" "$out_file"; then
              mv "$norm" "$out_file"
              ANY_CHANGED="true"
            else
              rm -f "$norm"
            fi

            rm -f "$tmpbody"
            return 0
          }

          # 1) Always fetch live list once (itâ€™s the source of truth for what is live)
          if [[ -z "${URL_LIVE:-}" ]]; then
            echo "URL_LIVE not set."
            echo "calls_used=0" >> "$GITHUB_OUTPUT"
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          LIVE_URL="${URL_LIVE}&league=${LEAGUE_ID}&season=${SEASON}"
          api_get_wrap "$LIVE_URL" "$LIVE_OUT" "matches" || true

          # 2) Build target fixture ids:
          #    - all live fixtures from LIVE_OUT
          #    - plus near kickoff fixtures from fixtures_week
          #    - plus post-window finished fixtures for up to 90m
          TMP_TARGETS="$(mktemp)"
          > "$TMP_TARGETS"

          if [[ -f "$LIVE_OUT" ]]; then
            jq -r '
              .matches[]?
              | select((.fixture.status.short // "" | ascii_upcase) as $s
                  | ($s=="1H" or $s=="HT" or $s=="2H" or $s=="ET" or $s=="P" or $s=="LIVE"))
              | .fixture.id
            ' "$LIVE_OUT" >> "$TMP_TARGETS" || true
          fi

          if [[ -f "$FIX" ]]; then
            NOW=$(date -u +%s)
            jq -r --argjson now "$NOW" --argjson win "${NEAR_KICKOFF_SECONDS}" '
              def to_ts($s):
                (try ($s
                  | sub("\\.[0-9]{3}Z$"; "Z")
                  | strptime("%Y-%m-%dT%H:%M:%S%z")
                  | mktime) catch null);

              .matches[]?
              | .fixture.date as $d
              | to_ts($d) as $ts
              | select($ts != null and ($ts - $now) >= 0 and ($ts - $now) <= $win)
              | .fixture.id
            ' "$FIX" >> "$TMP_TARGETS" || true
          fi

          if [[ -f "$POST" ]]; then
            NOW=$(date -u +%s)
            TS=$(jq -r '.ts // 0' "$POST")
            AGE=$((NOW - TS))
            if (( AGE >= 0 && AGE <= ${POST_WINDOW_SECONDS} )); then
              jq -r '.fixtures[]? // empty' "$POST" >> "$TMP_TARGETS" || true
            fi
          fi

          sort -u "$TMP_TARGETS" > "$TMP_TARGETS.uniq"
          mapfile -t TARGET_FIXTURES < "$TMP_TARGETS.uniq"

          echo "Target fixtures: ${#TARGET_FIXTURES[@]}"

          # 3) For each target fixture, refresh events+lineups+stats into matches/<id>/
          for fid in "${TARGET_FIXTURES[@]}"; do
            [[ -z "$fid" ]] && continue
            DIR="data/football/premier-league/matches/${fid}"

            ms_sleep "${PER_REQUEST_SLEEP_MS}"
            api_get_wrap "${EVENTS_URL}${fid}"   "${DIR}/events.json"  "events"  || true
            if [[ "$?" == "99" ]]; then break; fi

            ms_sleep "${PER_REQUEST_SLEEP_MS}"
            api_get_wrap "${LINEUPS_URL}${fid}"  "${DIR}/lineups.json" "lineups" || true
            if [[ "$?" == "99" ]]; then break; fi

            ms_sleep "${PER_REQUEST_SLEEP_MS}"
            api_get_wrap "${STATS_URL}${fid}"    "${DIR}/stats.json"   "stats"   || true
            if [[ "$?" == "99" ]]; then break; fi
          done

          # Update quota state
          NEW_COUNT=$((COUNT + CALLS_USED))
          jq --argjson c "$NEW_COUNT" '.count = $c' "$STATE" > "$STATE.tmp" && mv "$STATE.tmp" "$STATE"

          echo "calls_used=$CALLS_USED" >> "$GITHUB_OUTPUT"
          echo "changed=$ANY_CHANGED" >> "$GITHUB_OUTPUT"

      # ---------------------------------------------------------
      # Update post-window trigger:
      # store FT/AET/PEN fixtures that exist in live_today.json
      # (so we keep refreshing their match detail for 90m)
      # ---------------------------------------------------------
      - id: post
        name: Update post-window trigger
        if: steps.fetch.outcome == 'success'
        shell: bash
        run: |
          set -euo pipefail
          OUT="data/football/premier-league/live/live_today.json"
          POST="data/ops/post_window.json"

          [[ ! -f "$OUT" ]] && exit 0

          NOW_TS=$(date -u +%s)

          FINISHED_IDS=$(jq -r '
            [.matches[]?
              | select((.fixture.status.short // "" | ascii_upcase) as $s | ($s=="FT" or $s=="AET" or $s=="PEN"))
              | .fixture.id
            ] | unique | .[]
          ' "$OUT" || true)

          # If there are finished fixtures in this live snapshot, keep them in post window list
          if [[ -n "${FINISHED_IDS:-}" ]]; then
            jq -n --argjson ts "$NOW_TS" --argfile live "$OUT" '
              {
                ts: $ts,
                fixtures: (
                  $live.matches
                  | map(select((.fixture.status.short // "" | ascii_upcase) as $s | ($s=="FT" or $s=="AET" or $s=="PEN")))
                  | map(.fixture.id)
                  | unique
                )
              }
            ' > "$POST"
          fi

      - name: Commit & push
        if: steps.fetch.outputs.changed == 'true'
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "pl-bot"
          git config user.email "pl-bot@users.noreply.github.com"

          git add data/football/premier-league/live/live_today.json || true
          git add data/football/premier-league/matches/**/events.json || true
          git add data/football/premier-league/matches/**/lineups.json || true
          git add data/football/premier-league/matches/**/stats.json || true
          git add data/ops/live_usage.json || true
          git add data/ops/post_window.json || true

          git commit -m "Live PL refresh (live list + events/lineups/stats)" || true
          git push || true
