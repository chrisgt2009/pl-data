name: Refresh PL data

# 3) Let the current run complete (queue the next one)
concurrency:
  group: refresh-pl-data
  cancel-in-progress: false

on:
  schedule:
    # WEEKENDS (match-heavy): every 10 min 11:00–20:59 UTC
    - cron: "*/10 11-20 * * 6,0"
    # WEEKDAYS baseline: every 2 hours
    - cron: "0 */2 * * 1-5"
    # WEEKDAYS evenings: every 20 min, 18:00–22:59
    - cron: "*/20 18-22 * * 1-5"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    env:
      FD_TOKEN: ${{ secrets.FD_API_TOKEN }}
      UA: pl-bot/1.0 (+github.com/${{ github.repository }})

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure data dir
        run: mkdir -p data

      - name: Compute date window (UTC)
        id: dates
        shell: bash
        run: |
          echo "TODAY=$(date -u +%Y-%m-%d)" >> "$GITHUB_OUTPUT"
          echo "IN7=$(date -u -d '+7 days' +%Y-%m-%d)" >> "$GITHUB_OUTPUT"

      - name: Fetch with ETag (standings, fixtures_week, today)
        id: fetch
        shell: bash
        run: |
          set -e

          # Read previous ETags if present
          read_etag() {
            python - "$1" <<'PY' 2>/dev/null || true
import json,sys,os
path='data/etags.json'
key=sys.argv[1]
if os.path.exists(path):
    try:
        d=json.load(open(path))
        print(d.get(key,''))
    except Exception:
        pass
PY
          }

          ETAG_S="$(read_etag standings)"
          ETAG_W="$(read_etag fixtures_week)"
          ETAG_T="$(read_etag today)"

          URL_S="https://api.football-data.org/v4/competitions/PL/standings"
          URL_W="https://api.football-data.org/v4/competitions/PL/matches?dateFrom=${{ steps.dates.outputs.TODAY }}&dateTo=${{ steps.dates.outputs.IN7 }}"
          URL_T="https://api.football-data.org/v4/competitions/PL/matches?dateFrom=${{ steps.dates.outputs.TODAY }}&dateTo=${{ steps.dates.outputs.TODAY }}"

          fetch_one() {
            local url="$1"; local etag="$2"; local body="$3"; local head="$4"
            if [ -n "$etag" ]; then
              curl -sS --fail --retry 3 --retry-delay 2 --connect-timeout 15 \
                -H "User-Agent: $UA" -H "X-Auth-Token: $FD_TOKEN" -H "If-None-Match: $etag" \
                -D "$head" -o "$body" --write-out "%{http_code}" "$url"
            else
              curl -sS --fail --retry 3 --retry-delay 2 --connect-timeout 15 \
                -H "User-Agent: $UA" -H "X-Auth-Token: $FD_TOKEN" \
                -D "$head" -o "$body" --write-out "%{http_code}" "$url"
            fi
          }

          CODE_S="$(fetch_one "$URL_S" "$ETAG_S" standings.raw.json headers_s.txt || true)"
          CODE_W="$(fetch_one "$URL_W" "$ETAG_W" fixtures_week.raw.json headers_w.txt || true)"
          CODE_T="$(fetch_one "$URL_T" "$ETAG_T" today.raw.json headers_t.txt || true)"

          echo "code_s=$CODE_S" >> "$GITHUB_OUTPUT"
          echo "code_w=$CODE_W" >> "$GITHUB_OUTPUT"
          echo "code_t=$CODE_T" >> "$GITHUB_OUTPUT"

          ANY_CHANGED=false
          NEW_S=""; NEW_W=""; NEW_T=""

          if [ "$CODE_S" = "200" ]; then
            ANY_CHANGED=true
            NEW_S="$(grep -i '^etag:' headers_s.txt | awk '{print $2}' | tr -d '\r')"
          fi
          if [ "$CODE_W" = "200" ]; then
            ANY_CHANGED=true
            NEW_W="$(grep -i '^etag:' headers_w.txt | awk '{print $2}' | tr -d '\r')"
          fi
          if [ "$CODE_T" = "200" ]; then
            ANY_CHANGED=true
            NEW_T="$(grep -i '^etag:' headers_t.txt | awk '{print $2}' | tr -d '\r')"
          fi

          echo "any_changed=$ANY_CHANGED" >> "$GITHUB_OUTPUT"

          if [ "$ANY_CHANGED" = "true" ]; then
            python - <<PY
import json,os
et={}
p='data/etags.json'
if os.path.exists(p):
  try: et=json.load(open(p))
  except Exception: et={}
ns=os.environ.get('NEW_S') or et.get('standings')
nw=os.environ.get('NEW_W') or et.get('fixtures_week')
nt=os.environ.get('NEW_T') or et.get('today')
if ns: et['standings']=ns
if nw: et['fixtures_week']=nw
if nt: et['today']=nt
json.dump(et, open('data/etags.new.json','w'), separators=(',',':'), sort_keys=True)
PY
          fi
        env:
          NEW_S: ${{ steps.fetch.outputs.NEW_S }}
          NEW_W: ${{ steps.fetch.outputs.NEW_W }}
          NEW_T: ${{ steps.fetch.outputs.NEW_T }}

      - name: Normalize / slim (only when changed)
        if: steps.fetch.outputs.any_changed == 'true'
        shell: bash
        run: |
          python - <<'PY'
          import json, datetime
          from datetime import timezone
          now = datetime.datetime.now(timezone.utc)

          with open("standings.raw.json") as f: standings = json.load(f)
          with open("fixtures_week.raw.json") as f: fixtures_week = json.load(f)
          with open("today.raw.json") as f: today = json.load(f)

          # Standings (slim)
          out_s = {"season": standings.get("season"), "standings": standings.get("standings")}
          json.dump(out_s, open("data/standings.new.json","w"), separators=(",",":"), sort_keys=True)

          # teamId -> position
          pos={}
          for st in standings.get("standings", []):
              for row in st.get("table", []):
                  t=(row.get("team") or {})
                  tid=t.get("id")
                  if tid is not None: pos[tid]=row.get("position")

          # Fixtures next 7 days
          fw=[]
          for m in (fixtures_week.get("matches") or []):
              fw.append({
                  "id": m.get("id"),
                  "utcDate": m.get("utcDate"),
                  "status": m.get("status"),
                  "matchday": m.get("matchday"),
                  "homeTeam": m.get("homeTeam"),
                  "awayTeam": m.get("awayTeam"),
                  "score": (m.get("score") or {}).get("fullTime"),
                  "competition": {
                      "id": (m.get("competition") or {}).get("id"),
                      "code": (m.get("competition") or {}).get("code"),
                      "name": (m.get("competition") or {}).get("name"),
                  }
              })
          json.dump({
              "range": {"from": "${{ steps.dates.outputs.TODAY }}", "to": "${{ steps.dates.outputs.IN7 }}"},
              "matches": fw
          }, open("data/fixtures_week.new.json","w"), separators=(",",":"), sort_keys=True)

          # Live today (with serverNowUTC)
          def phase(status, utc_iso, now_utc):
              try:
                  kick = datetime.datetime.fromisoformat((utc_iso or "").replace("Z","+00:00"))
              except Exception:
                  return None, ""
              mins = int(max(0, (now_utc - kick).total_seconds() // 60))
              if status == "SCHEDULED": return mins, "Today"
              if status == "IN_PLAY":   return (mins, f"{mins}’") if mins < 90 else (mins, f"90+{mins-90}’")
              if status == "PAUSED":    return 45, "Half-Time"
              if status == "FINISHED":  return 90, "FT"
              return mins, status or ""

          live=[]
          for m in (today.get("matches") or []):
              st=m.get("status"); utc=m.get("utcDate")
              mins,label=phase(st,utc,now)
              ft=(m.get("score") or {}).get("fullTime") or {}
              h=(m.get("homeTeam") or {}); a=(m.get("awayTeam") or {})
              live.append({
                  "id": m.get("id"),
                  "utcDate": utc,
                  "status": st,
                  "approxMinute": mins,
                  "phase": label,
                  "home": {"id": h.get("id"), "tla": h.get("tla"), "name": h.get("name"),
                           "score": ft.get("home"), "pos": pos.get(h.get("id"))},
                  "away": {"id": a.get("id"), "tla": a.get("tla"), "name": a.get("name"),
                           "score": ft.get("away"), "pos": pos.get(a.get("id"))}
              })

          json.dump({
              "serverNowUTC": now.isoformat(),
              "lastUpdatedUTC": now.isoformat(),
              "matches": live
          }, open("data/live_today.new.json","w"), separators=(",",":"), sort_keys=True)

          json.dump({"lastUpdatedUTC": now.isoformat(), "serverNowUTC": now.isoformat()},
                    open("data/meta.new.json","w"), separators=(",",":"), sort_keys=True)
          PY

      - name: Commit only if changed
        if: steps.fetch.outputs.any_changed == 'true'
        shell: bash
        run: |
          set -e
          CHANGED=0
          for f in standings fixtures_week live_today meta etags; do
            if [ -f "data/$f.json" ] && [ -f "data/$f.new.json" ]; then
              if cmp -s "data/$f.new.json" "data/$f.json"; then
                rm -f "data/$f.new.json"
              else
                mv "data/$f.new.json" "data/$f.json"
                CHANGED=1
              fi
            elif [ -f "data/$f.new.json" ]; then
              mv "data/$f.new.json" "data/$f.json"
              CHANGED=1
            fi
          done
          if [ $CHANGED -eq 1 ]; then
            git config user.name "pl-bot"
            git config user.email "pl-bot@users.noreply.github.com"
            git add data/*.json
            git commit -m "Update PL data $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            git push
          else
            echo "No JSON changes to commit."
          fi
